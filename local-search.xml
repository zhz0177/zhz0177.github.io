<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>newbee mall搭建&amp;&amp;审计</title>
    <link href="/2025/10/27/newbee%20mall%E6%90%AD%E5%BB%BA&amp;&amp;%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/10/27/newbee%20mall%E6%90%AD%E5%BB%BA&amp;&amp;%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建："><a href="#搭建：" class="headerlink" title="搭建："></a>搭建：</h1><p>我用的是IDEA</p><ol><li><p>下载源码</p><p>链接如下：<a href="https://github.com/newbee-ltd/newbee-mall">https://github.com/newbee-ltd/newbee-mall</a></p><p>直接在github下载即可</p></li><li><p>在phpstudy打开web环境，新建数据库，如下：（<strong>数据库名称一定要是newbee_mall_db</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162925796.png" alt="image-20250929102955907"></p></li><li><p>然后导入sql文件（源码包里面就有）</p><p>记得先修改这个配置文件<code>（修改数据库名和用户名）</code></p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162930502.png" alt="image-20250926153103159" style="zoom:50%;" /><p>然后导入即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">\newbee-mall-master\src\main\resources\newbee_mall_schema.sql<br></code></pre></td></tr></table></figure></li><li><p>在Navicat Premium 17连接数据库</p><p> <img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162944166.png" alt="image-20250929103058046"></p></li><li><p>弹出即说明成功启动</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162946291.png" alt="image-20250926153457729"></p></li><li><p>直接输入</p><p><a href="http://localhost:28089/%E5%8D%B3%E5%8F%AF">http://localhost:28089/即可</a></p></li></ol><h1 id="审计："><a href="#审计：" class="headerlink" title="审计："></a>审计：</h1><h2 id="初审"><a href="#初审" class="headerlink" title="初审"></a>初审</h2><p><strong>先看pom.xml配置文件以及README.md</strong></p><ol><li><p>README.md中存在<strong>MyBatis</strong>，可能存在sql注入</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162948432.png" alt="image-20250929104432693"></p></li><li><p>通过搜索发现存在拦截器<strong>interceptor</strong>，可能存在越权漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162949866.png" alt="image-20250929104637782"></p></li><li><p>controller目录中也可能存在越权漏洞，下面具体审计可以跟着看一下</p><p>水平越权漏洞</p><ul><li>或者在篡改相关参数（请求参数 &#x2F; 表单字段 &#x2F; JSON 字段）</li><li>要么就是修改之中存在注入点，需要替换用户</li><li>在url使用参数切换用户或者管理员id未校验，尝试替换 ID（+1、-1、随机大&#x2F;小 ID、其它已知用户的 ID）</li><li>文件&#x2F;图片等直接用可访问 URL，访问其它用户的文件路径或修改 URL（没有权限校验或短期 token）</li><li>token 换取其他用户的数据</li><li>直接访问管理&#x2F;内部接口，扫列出隐藏路由、尝试访问 <code>/admin</code>、<code>/internal</code>、<code>/debug</code></li></ul></li></ol><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><ol><li><p>接上面说的，存在MyBatis，直接检索${，主要是查看${} 拼接 SQL 语句</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162953339.png" alt="image-20251014104614955"></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163139933.png" alt="image-20251014104622698"></p><p>都找不到和sql相关的东西</p><p>说明可能使用<code>#代替$</code>实现sql的预编译，防止了sql注入（可能是版本问题，这个漏洞修复了emmm）</p></li><li><p>查找<code>#&#123;</code></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162956964.png" alt="image-20251014105140910"></p><p>进去分析一下</p><p>使用了直接拼接的方式向数据库进行查询（但是预编译即已修复）</p></li><li><p>所以可以查看NewBeeMallGoodsMapper.java <strong>（逆向追踪）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027162958998.png" alt="image-20251014145410972"></p><p>找到传参定义，跟近函数</p></li><li><p>跟进到getTotalNewBeeMallGoods</p><p>C:\Users\95227\Desktop\newbee-mall-master\src\main\java\ltd\newbee\mall\service\impl\NewBeeMallGoodsServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">getNewBeeMallGoodsPage</span><span class="hljs-params">(PageQueryUtil pageUtil)</span> &#123;<br>        List&lt;NewBeeMallGoods&gt; goodsList = goodsMapper.findNewBeeMallGoodsList(pageUtil);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> goodsMapper.getTotalNewBeeMallGoods(pageUtil);<br>        <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(goodsList, total, pageUtil.getLimit(), pageUtil.getPage());<br>        <span class="hljs-keyword">return</span> pageResult;<br>    &#125;<br></code></pre></td></tr></table></figure><p>查看谁调用了getNewBeeMallGoodsPage 方法</p></li><li><p>跟进到NewBeeMallGoodsController</p><p>C:\Users\95227\Desktop\newbee-mall-master\src\main\java\ltd\newbee\mall\controller\admin\NewBeeMallGoodsController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/goods/list&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; params)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(params.get(<span class="hljs-string">&quot;page&quot;</span>)) || ObjectUtils.isEmpty(params.get(<span class="hljs-string">&quot;limit&quot;</span>))) &#123;<br>            <span class="hljs-keyword">return</span> ResultGenerator.genFailResult(<span class="hljs-string">&quot;参数异常！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">PageQueryUtil</span> <span class="hljs-variable">pageUtil</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageQueryUtil</span>(params);<br>        <span class="hljs-keyword">return</span> ResultGenerator.genSuccessResult(newBeeMallGoodsService.getNewBeeMallGoodsPage(pageUtil));<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>传入了 pageUtil 参数，而该参数同样通过 PageQueryUtil 类创建一个 pageUtil 对象，传入 params 作为参数，以及 params 同样是个 Map 对象。未对其进行过滤处理</p></li><li><p>针对版本低的源码（未修复的）</p><p>直接抓包，报错注入，sqlmap跑就行了（我的漏洞已经“预编译”修复，所以我就不演示了哈）</p></li></ol><h2 id="后台权限绕过"><a href="#后台权限绕过" class="headerlink" title="后台权限绕过"></a>后台权限绕过</h2><p>说到后台，肯定先看admin相关文件啊，所以可以找找登录后台的文件（AdminLogin）</p><ol><li><p>进入src&#x2F;main&#x2F;java&#x2F;ltd&#x2F;newbee&#x2F;mall&#x2F;interceptor&#x2F;AdminLoginInterceptor.java</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163002814.png" alt="image-20251014191955489"></p><p>第一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">requestServletPath</span> <span class="hljs-operator">=</span> request.getServletPath();<br></code></pre></td></tr></table></figure><p>使用getServletPath传入url： getRequestURI 方法返回的路径是未经过服务器端处理的原始路径，可能包含特殊字符或路径跳转，从而绕过服务器端的安全控制</p><p>第二步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (requestServletPath.startsWith(<span class="hljs-string">&quot;/admin&quot;</span>) &amp;&amp; <span class="hljs-literal">null</span> == request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>)) &#123;<br></code></pre></td></tr></table></figure><p>先判断 Uri 路径中是否以 &#x2F;admin 开头，然后以及获取并判断Session 中的 loginUser 属性是否为 null</p><p>两个条件 &amp;&amp; 在一起结果为 True 的话进入条件代码</p></li><li><p>payload：</p><ul><li><p>登陆后台寻找一个后台接口（账号密码是弱密码，考考大家吧🤭）<br><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163004797.png" alt="image-20251014193025547"></p></li><li><p>删除cookic之后，查看回显</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163006124.png" alt="image-20251014193040005"></p><p>明显报错了</p></li><li><p>绕过</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163008180.png" alt="image-20251014193103330"></p></li></ul></li></ol><h2 id="XSS漏洞（1，2）"><a href="#XSS漏洞（1，2）" class="headerlink" title="XSS漏洞（1，2）"></a>XSS漏洞（1，2）</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p>啥也不知道，先在前端进行测试（找那种可以保留的对话框，类似于评论&#x2F;弹幕的那种）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163010034.png" alt="image-20251014193404446"></p><p>搜索xss的代码<strong>没有弹窗</strong>（我觉得应该是因为存在双引号，将代码包起来了）</p></li><li><p>去源码中找找原因（源代码好找，看现在的url，在源代码文件夹寻找相关的代码就行）</p><p>（不明确的话，存在keyword传参，所以直接在项目文件里面搜索keyword即可）</p><p><strong>存在转义</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163014918.png" alt="image-20251014194012915"></p></li><li><p><strong>thymeleaf模版</strong>在对th:text标签进行渲染的时候，默认对特殊字符进行了转义</p><p>接着进入search.html<br>src\main\resources\templates\mall\search.html</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163016401.png" alt="image-20251014201622548"></p><p>找thymeleaf未作转义的输出，th:utext不会将字符转义</p><ul><li><p>第一个，存在th:utext，所以这两个功能点存在XSS。</p></li><li><p>第二个，detail.html因为显示的是商品信息，商品信息使用富文本编辑器，不能简单的转义处理，需要考虑正常的html标签传输，所以作者在这里使用th:utext来显示商品详细。</p></li></ul></li></ol><h3 id="xss（1）："><a href="#xss（1）：" class="headerlink" title="xss（1）："></a>xss（1）：</h3><p>进入商品信息，添加xss的payload</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163018219.png" alt="image-20251014204318619"><br>然后（提交即可弹窗）<br><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163019713.png" alt="image-20251014204241804"></p><h3 id="xss（2）："><a href="#xss（2）：" class="headerlink" title="xss（2）："></a>xss（2）：</h3><ol><li><p>进入订单管理，然后添加payload</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163021921.png" alt="image-20251014204504188"></p></li><li><p>提交即可弹窗</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163024553.png" alt="image-20251014204615252"></p></li></ol><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><ol><li><p>上面提到过，存在interceptor拦截器（可以寻找相关函数）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163026770.png" alt="image-20251015154849036"></p></li><li><p>步入看一下</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163028092.png" alt="image-20251015155304419"></p><p>对url路径设置了不同的interceptor</p><p>addPathPatterns表示其中的路径会经过设置的拦截器，excludePathPatterns不过该拦截器</p><p><code>其中两个星**表示匹配任意字符。如果出现一个星*则表示匹配单个路径</code></p></li><li><p>找到拦截器，下面就要看登录页面，所以可以跟进一下NewBeeMallLoginInterceptor</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163029780.png" alt="image-20251015210304376"></p><p>用 getServletPath() 来获取最后真正分发到路由地方的 path，getRequestURI() 只是获取了请求的 URl</p><p>这个意义不大</p><p>所以找一下下一个类AdminLoginInterceptor</p></li><li><p>AdminLoginInterceptor，就是第二步骤里面的类名</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163031202.png" alt="image-20251015210714466"></p><p>使用了 getRequestURI() 来获取URI来判断URI是否以 &#x2F;admin 开头，如果是 &#x2F;admin 开头则校验 session，不是则不用校验（其实这个和上面那个后台权限绕过的类似，都定位到这里了）</p></li><li><p>payload</p><ul><li><p>进入dashboard模块</p><p>输入&#x2F;&#x2F;admin 或 &#x2F;index&#x2F;..;&#x2F;admin也可以成功访问到页面</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163033016.png" alt="image-20251015211040611"></p><p>成功绕过了目录访问字符限制</p></li></ul></li></ol><h2 id="水平越权漏洞（1，2）"><a href="#水平越权漏洞（1，2）" class="headerlink" title="水平越权漏洞（1，2）"></a>水平越权漏洞（1，2）</h2><p>上面的分析已经提前说过了</p><p>可以看一下Controller的<strong>相关文件</strong>，直接看controller<strong>目录</strong>也行，可能存在<strong>水平越权漏洞</strong></p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ol><li><p>在文件里面全局搜索<strong>Controller</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163034498.png" alt="image-20251015211548470"></p></li><li><p>寻找到目标文件（初审里面总结一小部分注入点）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163036179.png" alt="image-20251015212148806"></p></li><li><p>接着看 updateUserInfo() 的<strong>实现</strong><br>src\main\java\ltd\newbee\mall\service\impl\NewBeeMallUserServiceImpl.java</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163037476.png" alt="image-20251015213516667"></p><p>发现这里从数据库查找用户并未用到 session ，而是直接以传递过来的 userId 为参数来查找并修改数据的，所以这里存在水平越权漏洞，修改 userId 便可修改其他用户的信息。</p></li><li><p>payload</p><ul><li><p>注册一个用户，然后查看个人信息</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163038729.png" alt="image-20251015213807750"></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163215149.png" alt="image-20251015213844712"></p></li><li><p>使用burp抓包，修改用户 userId <img src="C:\Users\95227\AppData\Roaming\Typora\typora-user-images\image-20251015214259650.png" alt="image-20251015214259650" style="zoom:33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163044634.png" alt="image-20251015214436198"></p><p>ok，回显成功</p></li></ul></li></ol><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ol><li><p>还是根据上面的流程进入OrderController（查询订单）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163046794.png" alt="image-20251015215316713"></p></li><li><p>跟进getOrderDetailByOrderNo() 函数<br>src\main\java\ltd\newbee\mall\service\impl\NewBeeMallOrderServiceImpl.java</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163048125.png" alt="image-20251015215401216"></p><p>还是id问题，输入其他id，可以查看其他人的cookic，没有绕过限制</p></li><li><p>payload</p><p>跟上面一样抓包+改数据即可</p><p>我就不演示了🤭，我相信各位大佬可以</p></li></ol><h2 id="Csrf漏洞"><a href="#Csrf漏洞" class="headerlink" title="Csrf漏洞"></a>Csrf漏洞</h2><ol><li><p>添加购物车功能，抓包，查看请求内容，没有任何token值来进行校验</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163053058.png" alt="image-20251015215926101"></p></li><li><p>由于是json格式的请求，不能直接使用burp Generate CSRF PoC，因为burp生成的PoC无法伪造Content-Type。burp生成的CSRF PoC请求内容如下，可以看到Content-Type: text&#x2F;plain，并且post数据多出一个等号</p><p>直接在bp的插件里面生成csrf的代码就行</p><p>是一个html</p></li><li><p>payload</p><ul><li><p>对上面生成csrf的poc进行抓包</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163055483.png" alt="image-20251015220131216"></p></li><li><p>然后成功写入xss的payload</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163105549.png" alt="image-20251015220157720"></p></li><li><p>查看页面，成功添加</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163106531.png" alt="image-20251015220232223"></p></li></ul></li></ol><h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><ol><li><p>下订单但未支付时，访问&#x2F;orders&#x2F;{orderNo}&#x2F;finish可直接完成交易</p><p>直接看代码</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163113629.png" alt="image-20251015220420234"></p><p>从代码中发现直接调用newBeeMallOrderService.finishOrder(orderNo, user.getUserId())，对于该订单是否支付，是否出库等过程都<strong>没有校验</strong></p></li><li><p>put方式去请求即可（左边标黄的就是  <strong>putmapping</strong>）<img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163114921.png" alt="image-20251015220657894"></p></li><li><p>payload</p><ul><li><p>添加一件物品到购物车，然后提交订单</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163116396.png" alt="image-20251015220904271"></p></li><li><p>点击去支付，一系列流程下来可以购买商品</p><p>管理员查看显示  待支付</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163118857.png" alt="image-20251015221005435"></p></li><li><p>我们使用put方式去请求</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027163121952.png" alt="image-20251015221101972"></p></li><li><p>查看回显成功支付商品</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java入门</title>
    <link href="/2025/10/27/java%E5%85%A5%E9%97%A8/"/>
    <url>/2025/10/27/java%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h2><ol><li><p>输入&amp;输入方法（比如是输入hello  world）</p><ul><li><p>next（）输入字符串不能存在空格      （输出hello）</p></li><li><p>nextLine（），回车前的所有字符，可以获取到空格     （输出hello  world）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xxxxx.xxx.xxx<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 从键盘接收数据</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入数据：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;输出的内容为：&quot;</span>+str);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (scanner.hasNextInt()) &#123;    <span class="hljs-comment">//这个条件是判断 输入是不是整数的</span><br>    i = scanner.nextInt();<br>    System.out.println(<span class="hljs-string">&quot;整数数据：&quot;</span> + i);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;输入的不是整数数据：&quot;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>判断字符串有函数：<br>x.equal（“xcsccsc”）     判断x输入字符串和xcsccsc字符串是否相等</p></li></ol><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ol><li><p>if</p><ul><li><p>单层–if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>两层–if    else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多层–if   else if   else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>()&#123;<br>    System.out.println(<span class="hljs-string">&quot;*****&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>switch case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>        <span class="hljs-comment">//语句</span><br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>        <span class="hljs-comment">//语句</span><br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>        <span class="hljs-comment">//语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>switch变量类型：byte   short   int   char   <strong>string</strong>（java7以后）</li><li>case变量类型：字符串常量  自变量</li><li>case穿透：不写break就在条件后<strong>全执行</strong></li></ul></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li><p>while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(布尔值)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意要写退出循环的限制条件，不然会变成死循环</p><p>eg：i++；</p></li><li><p>do  while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jaVA"><span class="hljs-keyword">do</span>&#123;<br>    <br>&#125;<span class="hljs-keyword">while</span>();<span class="hljs-comment">//注意有分号</span><br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化（可以空）;布尔表达式;更新)&#123;<span class="hljs-comment">//分号隔开</span><br>    代码语句<br>&#125;<br></code></pre></td></tr></table></figure><p>在idea里面，写<strong>100.for</strong>可以直接生成</p></li><li><p>增强for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;; <span class="hljs-comment">//定义了一个数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x:numbers)&#123;<br>            System.out.println(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历数组，每次for循环输出</p></li></ol><ul><li><p>While和do-While的区别:]</p><p>while先判断后执行。dowhile是先执行后判断!</p><p>Do…while总是保证循环体会被<strong>至少执行一次</strong>!这是他们的主要差别</p></li><li><p>break&amp;&amp;continue</p><p>break用于强制退出循环，不终止程序（放在判断后）</p><p>continue只是这一次不执行，下一次继续执行</p><p>（goto在java<strong>不存在</strong>）但是可以利用标签使用，起跳转作用</p></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>方法类似于函数</p><ul><li><p>System.out.printIn()<br>类.对象.方法</p></li><li><p>Java方法是语句的集合，它们在一起执行一个功能</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span>&#123;<br>    <span class="hljs-comment">//main方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[]args)</span>&#123;<br>        <span class="hljs-type">int</span> sum=add(a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>);System.out.println(sum);<br>    &#125;<br><span class="hljs-comment">//加法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在写方法的时候<code>public  int add(int a,int b)</code>，要想调就要加一个<code>static</code></p><ul><li><p>设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，<strong>就是一个方法只完成1个功能，这样利于我们后期的扩展</strong></p><p>可以多用写一些方法，把main函数变得更加简洁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ....<br>    <span class="hljs-keyword">return</span> 返回值;<span class="hljs-comment">//有返回类型，一定要写return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><ul><li>当方法返回一个值的时候，方法调用通常被当做一个值</li><li>如果方法返回值是void，方法调用一定是一条语句</li></ul><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数名称相同，参数类型不同（返回值是谁，就调用谁）</p><p><code>参数类型也可以相同，在方法里面强制转化就行</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> num1,<span class="hljs-type">double</span> num2)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (num1==num2)&#123;<br>        System.out.println(<span class="hljs-string">&quot;num1==num2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//终止方法</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (num1&gt;num2)&#123;<br>        result = (<span class="hljs-type">int</span>)num1;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        result = (<span class="hljs-type">int</span>)num2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在调用的时候，要调配和方法相匹配，要不编译器会报错</p><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandLine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;args.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;args[&quot;</span> + i + <span class="hljs-string">&quot;]: &quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125533446.png" alt="image-20251022090113344"></p><p>直接在idea里面的命令行运行不成功，所以打开方法-所在文件夹，使用命令行编译，发现还是不行</p><p>因为运行需要在src目录下，回退完目录后，再次运行</p><p>源码定义的是一个数组，所以在语句后面跟上参数<code>this is kuangshen</code></p><p>发现成功返回</p><p><strong>也就是说main方法也是可以传参的</strong></p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>本质就是一个数组</p><ul><li>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。、</li><li>在方法声明中，在指定参数类型后加一个省略号(…)  </li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo04</span> <span class="hljs-variable">demo04</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo04</span>();<br>        demo04.test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">45</span>,<span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span>... i)</span>&#123;<br>        System.out.println(i[<span class="hljs-number">0</span>]);<br>        System.out.println(i[<span class="hljs-number">1</span>]);<br>        System.out.println(i[<span class="hljs-number">2</span>]);<br>        System.out.println(i[<span class="hljs-number">3</span>]);<br>        System.out.println(i[<span class="hljs-number">4</span>]);<br>        System.out.println(i[<span class="hljs-number">5</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>自己调用自己</p><p>简单来说就是找到公式规律，然后往前一个未知数推导（复杂问题，简单化，减少重复计算，减少代码量）</p><ul><li><p>递归结构包括两个部分：</p><p>递归头:什么时候不调用自身方法，如果没有头，将陷入死循环</p><p>递归体:什么时候需要调用自身方法</p></li></ul><p>java主要使用的是栈，就是罐子里面一个叠一个，<strong>先放后拿</strong> </p><h2 id="静态-非静态"><a href="#静态-非静态" class="headerlink" title="静态&amp;非静态"></a>静态&amp;非静态</h2><ul><li><p>静态：有static</p><p>在其他类里面写，可以在main里面调用 <code>类.方法</code></p></li><li><p>非静态：</p><p>调用：将类实例化new———&gt;对象类型  对象名&#x3D;对象值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125532966.png" alt="image-20251022215227014"></p></li></ul><h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><ul><li>有static，和类一起加载，存在较早</li><li>无static，在类实例化之后才存在，比上面那个迟</li></ul><p>所以<strong>不能</strong>在有static，调用无static的方法</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125535537.png" alt="image-20251022215527356"></p><p><strong>b（）</strong>明显报错了</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>定义一组类型，相同类型的有序集合，通过下标访问</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jaVa"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(stringl args)</span>&#123;<br>    <span class="hljs-type">int</span>[] nums; <span class="hljs-comment">//1.定义</span><br>    <span class="hljs-type">int</span> nums2[];<span class="hljs-comment">//2.c和c++使用的多</span><br>&#125;<br></code></pre></td></tr></table></figure><p>没定义，返回默认值（int 的默认值就是0）</p><p>获取数组长度是<code>arrays。length</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li><p>静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 静态初始化: 创建 + 赋值</span><br>       <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>       System.out.println(a[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></li><li><p>动态初始化（<code>包含默认初始化</code>）</p><p>先分配内存（初始化）（变成默认值），再赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态初始化 : 包含默认初始化</span><br>       <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>       b[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li><li><p>数组的默认初始化</p><p>就是分配内存的初始化</p></li></ul><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><ol><li>堆</li><li>栈</li><li>方法区</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">步骤 <span class="hljs-number">1</span>：声明数组<br>代码<span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;声明了一个整型数组变量<span class="hljs-keyword">array</span>，并将其初始化为<span class="hljs-keyword">null</span>，表示该数组目前没有指向任何实际的数组对象<br><br>步骤 <span class="hljs-number">2</span>：创建数组<br>代码<span class="hljs-keyword">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];创建了一个长度为 <span class="hljs-number">10</span> 的整型数组，并将其引用赋值给<span class="hljs-keyword">array</span>变量，此时数组的每个元素都有了默认值（整型数组默认值为 <span class="hljs-number">0</span>）<br><br>步骤 <span class="hljs-number">3</span>：给数组元素赋值<br>代码通过类似nums[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;这样的语句（这里变量名可能存在笔误，应为<span class="hljs-keyword">array</span>），给数组的每个元素依次赋值，从<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>]到<span class="hljs-keyword">array</span>[<span class="hljs-number">9</span>]分别赋值为 <span class="hljs-number">1</span> 到 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>先声明空数组（栈），在new一个数组（在堆内部分配空间），然后赋值（赋值）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125540714.png" alt="image-20251022153931969"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是相同类型,不允许出现混合类型</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li><li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</li><li>数组<strong>本身就是对象</strong>，Java中对象是在堆中的因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong></li><li>数组下标越界会报错（边界异常）</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>打印所有的数组元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrays.length; i++) &#123;<br>            System.out.println(arrays[i]);<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>计算sum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrays.length; i++) &#123;<br>          sum += arrays[i];<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;sum=&quot;</span> + sum);<br></code></pre></td></tr></table></figure></li><li><p>寻找max</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arrays[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arrays.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arrays[i] &gt; max) &#123;<br>                max = arrays[i];<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>增强for循环</p><p><code>快捷语句：array.for</code>        省略了数组下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> array  :  array)&#123;<span class="hljs-comment">//int array相当于下标，array相当于这个数组</span><br>    System.out.println(array);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分装成方法的参数&#x2F;&#x2F;数组作为返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打印数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arrays)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrays.length; i++) &#123;<br>            System.out.print(arrays[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125; <br><br><span class="hljs-comment">//反转数组 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverse(<span class="hljs-type">int</span>[] arrays)&#123;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arrays.length];<br><br>    <span class="hljs-comment">//反转的操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j=result.length-<span class="hljs-number">1</span>; i &lt; arrays.length; i++,j--) &#123;<br>        result[j] = arrays[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组</p><p>数组的多重嵌套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输出二维数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array[i].length ; j++) &#123;<br>                System.out.println(array[i][j]);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ul><li>第一个条件 <code>i &lt; array.length</code> 是限制<strong>行下标 <code>i</code></strong> 的，<code>array.length</code> 表示二维数组的行数，确保 <code>i</code> 不会超出行的范围。</li><li>第二个条件 <code>j &lt; array[i].length</code> 是限制<strong>列下标 <code>j</code></strong> 的，<code>array[i].length</code> 表示第 <code>i</code> 行的列数，确保 <code>j</code> 不会超出当前行的列范围。</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>arrays类</p><ul><li>数组的工具类java.util.Arrays</li><li>由于数组对象本身并没有什么方法可以供我们调用,但API中提供了一个工具类Arrays供我们使用,从而可以对数据对象进行一些基本的操作。</li><li>查看JDK帮助文档</li><li>Arrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用,而”不用“使用对象来调用(注意:是”不用”而不是“不能”)</li><li>具有以下常用功能:<br>◆给数组赋值:通过 fi 方法。<br>◆对数组排序:通过 sort 方法,<strong>升序</strong>,<br>◆比较数组:通过 equals 方法比较数组中元素值是否相等<br>◆查找数组元素:通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul></li><li><p>冒泡排序（两层循环）</p><p>两两相邻比较，出现大小差异就交换顺序</p><p>每次比较都会出现max和min，下一轮就减少一次循环</p><p>依次循环，直到结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br>    <span class="hljs-comment">//临时变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//外层循环，判断我们这个要走多少次；</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//内层循环，比价判断两个数，如果第一个数，比第二个数大，则交换位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length-<span class="hljs-number">1</span>-i ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j+<span class="hljs-number">1</span>]&gt;array[j])&#123;<br>                temp = array[j];<br>                array[j] = array[j+<span class="hljs-number">1</span>];<br>                array[j+<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>稀疏数组</p><ul><li><p>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组</p></li><li><p>稀疏数组的处理方式是:</p><p>◆记录数组一共有几行几列，有多少个不同值<br>◆把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125545873.png" alt="image-20251022164858914"></p><p>左边是原始数组，右边是压缩数组</p><ul><li>共六行七列（除去0），只有8个有效数字——-&gt;初始数组都是0（初始化）</li><li>后面就是坐标定位有效值                            ——-&gt;赋值替换有效值</li></ul></li></ol><h1 id="面向对象（op）"><a href="#面向对象（op）" class="headerlink" title="面向对象（op）"></a>面向对象（op）</h1><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>面向对象    vs      面向过程</p><ul><li>面向对象：是线性的（第一步，第二步这样）——&gt;框架</li><li>面向过程：是分类思维（分类进行独立思考）——&gt;流程</li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>面尚对象编程的本质就是:<strong>以类的方式组织代码，以对象的组织(封装)数据</strong></p><p>三大特性:<strong>封装   继承   多态</strong></p><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象</p><p>从<strong>代码运行角度考虑是先有类后有对象</strong>。类是对象的模板。</p><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><ol><li><p>一个项目应该只存在一个main方法</p></li><li><p>一个类里面，只有可能存在<strong>属性和方法</strong>这俩东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性：字段</span><br>    String name;<span class="hljs-comment">//默认值nell</span><br>    <span class="hljs-type">int</span> age;<span class="hljs-comment">//默认值0</span><br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;在学习&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this.name</code>指的是在这个类里面的属性</p></li><li><p>类——-&gt;对象           抽象——-&gt;实例</p><p>先输入 <code>new 类名()</code>（如 <code>new Student()</code>），然后使用快捷键 **<code>Ctrl + Alt + V</code>**，IDEA 会自动生成变量声明语句（如 <code>Student student = new Student();</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类：抽象的，实例化</span><br>        <span class="hljs-comment">//类实例化后会返回一个自己的对象！</span><br>        <span class="hljs-comment">//student对象就是一个Student类的具体实例！</span><br>        <br><span class="hljs-type">Student</span> <span class="hljs-variable">xiaoming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//Student student = new student();</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">xh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//Student student = new student();</span><br><br>xiaoming.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    xiaoming.age = <span class="hljs-number">3</span>;<br><br>System.out.println(xiaoming.name);<br>System.out.println(xiaoming.age);<br><br>System.out.println(xh.name);<br>System.out.println(xh.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>结合上面写的，xiaoming.name &#x3D; “小明”;          xiaoming.age &#x3D; 3;这个对象已经赋值，所以返回赋值内容</p><p>xh这个对象并没有赋值，所以返回默认值</p></li></ol><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>生成alt+insert</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java ---&gt; class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-comment">//一个类即使什么都不写，它也会存在一个方法</span><br>    <span class="hljs-comment">//显示的定义构造器</span><br>    String name;<br><br>    <span class="hljs-comment">//实例化初始值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个项目应该只存一个main方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new 实例化了一个对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//////如果在里断点</span><br><br>        System.out.println(person.name); <span class="hljs-comment">//aaaa</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用断点检测：</p><ol><li>没走就是null</li><li>先到类里面的public Person</li><li>后面赋值”小明”（赋值是person类里面的  <code>String name;</code>）</li><li>接着再次回到new</li><li>然后接着往下走</li></ol><p>作用：</p><ul><li>使用new关键字，不质是在调用构造器</li><li>用来初始化值</li></ul><p>构造器:<br>1.和类名相同<br>2.没有返回值<br>作用:<br>1.new 本质在调用构造方法<br>2.初始化对象的值<br>注意点:<br>1.定义有参构造之后，如果想使用无参构造，显示的定义一个无参的构造<br>2.alt+insert<br>3.this.     &#x3D;      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>类<br><span class="hljs-number">2.</span>方法<br><span class="hljs-number">3.</span>引用类型:基本类型(<span class="hljs-number">8</span>)对象是通过引用来操作的:栈---&gt;堆<br><span class="hljs-number">4.</span>属性:字段Field 成员变量<br>默认初始化:<br>数字:<span class="hljs-number">8</span><br><span class="hljs-number">0.8</span><br>u0000char :<br><span class="hljs-type">boolean</span>:<span class="hljs-literal">false</span><br>引用:<span class="hljs-literal">null</span><br>修饰符 属性类型 属性名= 属性值!<br><span class="hljs-number">5.</span>对象的创建和使用<br>-必须使用<span class="hljs-keyword">new</span> 关键字创造对象，构造器 <span class="hljs-type">Person</span> <span class="hljs-variable">kuangshen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();-对象的属性kuangshen.name对象的方法kuangshen.sleep()<br>类:静态的属性动态的行为<br></code></pre></td></tr></table></figure><p>理解：</p><p>构造器随着对象创建而直接调用，而使用方法还得手动调用</p><p>（就像，人出生就伴随的  身份证号码，是否在呼吸；但是跑步，游泳是可选择的）</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li><p>该露的露，该藏的藏</p></li><li><p>我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合:仅暴露少量的方法给外部使用。</p></li><li><p>封装(数据的隐藏)：<br>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏</p></li></ul><p><strong>属性私有，get&#x2F;set</strong></p><p><img src="C:\Users\95227\Desktop\image-20251024164516243.png" alt="image-20251024164516243"></p><p><code>private</code>私有属性之后，在main里面调用就会报错</p><p><code>public</code>就不会</p><h3 id="如何调用："><a href="#如何调用：" class="headerlink" title="如何调用："></a>如何调用：</h3><p>get&#x2F;set（快捷键alt+insert）</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125555451.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.setName(<span class="hljs-string">&quot;秦疆&quot;</span>);<br>        System.out.println(s1.getName());<br>        s1.setAge(-<span class="hljs-number">1</span>);<span class="hljs-comment">//不合法的</span><br>        System.out.println(s1.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>get用于Application的调用后的<strong>输出</strong>，set用于调用<strong>赋值</strong></p><p>意义：</p><ul><li><p>提高程序的安全性，保护数据</p><p>也可以直接在封装内部附加条件，对不合法信息进行过滤</p></li><li><p>隐藏代码的实现细节</p><p>封装之后看不到，数据隐藏</p></li><li><p>统一接口</p><p>只使用get和set接口</p></li><li><p>系统可维护增加了</p></li></ul><p><strong>理解为什么要封装：</strong></p><p>使用有if的<code>public</code>方法&amp;&amp;使用内部if的<code>private</code></p><p>public：有条件，可以不走条件，公开属性可以修改（绕过过滤）</p><p>private：有条件，必须走条件，不合法只能被拦截</p><p>比如：</p><ul><li>public你家大门上挂了个 “请按门铃” 的牌子，大门没锁<ul><li>有素质的人会按门铃</li><li>但没素质的人可以直接推门而入，牌子形同虚设</li></ul></li><li>private想进门必须按门铃（必须调用方法），想绕都绕不过去</li></ul><h2 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h2><p>比如println可以输出许多东西</p><p>步入方法就会知道，写了   许多<code>相同方法名</code>的<code>不同参数</code>的<code>方法</code></p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125559530.png" alt="image-20251024172431860"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p></li><li><p>extends的意思是“扩展”。子类是父类的扩展</p></li><li><p><strong>JAVA中类只有单继承，没有多继承!<strong>（但是可以通过接口实现）（想了解的直接跳的</strong>接口</strong>标题查看）</p><p>一个儿子一个爹；一个爹好几个儿子</p><p>◆ 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等</p><p>◆ 继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。子类继承父类,使用关键字extends来表示,</p><p>◆ 子类和父类之间,从意义上讲应该具有”is a”的关系.</p><p>◆ 子类可以继承父类的所有<strong>方法</strong></p><p>◆ 子类<strong>无法</strong>继承父类private</p><p>但是可以通过get&#x2F;set通过一些特定条件来调用（不能继承，但是留了点接口；不能让你随便花钱，但是可以给你留点）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>学生 是 人（student继承 person）</p><p><strong>感觉像是树形图</strong>（ctrl+H可以打开继承树）</p><ul><li><p>也可以组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    Person person;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>父类上面，还有object：</p><p><img src="C:\Users\95227\AppData\Roaming\Typora\typora-user-images\image-20251024173831717.png"></p><p>因为object是所有类的父类，所有的类，都默认直接或者间接继承object</p></li></ul><h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><ul><li><p>Super对比this</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125603049.png" alt="image-20251024174447756"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(name); <span class="hljs-comment">// 输出方法的传参参数</span><br>System.out.println(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// 输出当前类的成员变量</span><br>System.out.println(<span class="hljs-built_in">super</span>.name); <span class="hljs-comment">// 输出父类的成员变量</span><br></code></pre></td></tr></table></figure></li><li><p>类内部有默认的构造器<br>在的父类写构造器，写输出<br>在子类写构造器，写输出<br>在所在类内部new一个子类，执行发现：先输出父类，在输出子类<br>也就是说，存在隐藏代码，就是调用父类的构造器</p><p>如果父类是有参的，子类是无参的<br>new一个对象发现，调用不了（父类不能用，子类也不能用）</p></li><li><p>总结</p><ul><li><p>super注意点:<br>1.super调用父类的构造方法，必须在构造方法的第一个</p><p>2.super 必须只能出现在子类的方法或者构造方法中!</p><p>3.super和 this 不能同时调用构造方法!</p><p>​因为这两个都要放在第一行，一起用就冲突了</p></li><li><p>Vs this:<br>代表的对象不同:<br>this:本身调用者这个对象</p><p>super:代表父类对象的应用</p><p>前提：<br>this：没有继承也可以使用<br>super：只能在继承条件才可以使用</p><p>构造方法：</p><p>this()：本类的构造<br>super()：父类的构造!</p></li></ul></li></ul><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>是方法的重写，和属性无关</p><ul><li><p>有static的情况</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125605929.png" alt="image-20251024211537644"></p><p>父类有text方法，子类也有text方法</p><p>调用时，A和B方法不同，但是<strong>父类的引用指向了子类</strong></p><p>静态方法不支持重写</p><p>这<strong>不是</strong> “方法重写”，（因为静态方法不支持重写，只是 “子类定义了同名静态方法）</p></li><li><p>无static</p><p>而且重写的关键词只能是public不能是private</p><p>而且还会出现注释  @Override</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125608057.png" alt="image-20251024212744560"></p><p>相当于子类重写了父类的方法</p><p>第一个输出是子类的</p><p>第二个输出还是子类（B   b &#x3D; new A()  父类被重写）</p></li></ul><p>总结：</p><p>重写:需要有继承关系，子类重写父类的方法!<br>1.方法名必须相同<br>2.参数列表列表必须相同<br>3.修饰符:范围可以扩大但不能缩小                      public&gt;Protected&gt;Default&gt;private<br>4.抛出的异常:范围，可以被缩小，但不能扩大:  classNotFoundException （小）—–&gt;Exception(大)<br>重写，子类的方法和父类必要一致;方法体不同!</p><p>为什么需要重写:<br>父类的功能，子类不一定需要，或者不一定满足</p><p><strong>重写   VS   重载</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125609553.png" alt="image-20251024213257448"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>其实上面说的重写就是体现多态</p><p>为了让子类能够根据自身特性 “定制” 父类的行为，从而让代码更灵活、更贴合场景</p><p>就是我在上面写的    <code>有static的情况</code>   和  <code>无static的这两种</code></p><p><strong>注意事项：</strong></p><ol><li>多态是方法的多态，属性没有多态</li><li>父类和子类，有联系 类型转换异常！ClassCastException！</li><li>存在条件： 继承关系，方法需要重写，父类引用指向子类对象！ Father f1 &#x3D; new Son ();</li></ol><p>不能重写的：</p><ol><li>static 方法，属于类，它不属于实例</li><li>final 常量；</li><li>private 方法；</li></ol><h2 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h2><ul><li><p>instanceof</p><p>(类型转换) 引用类型，判断一个对象是什么类</p><p><strong>满足父子关系就是ture    否则就是false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//Object &gt; String</span><br>    <span class="hljs-comment">//Object &gt; Person &gt; Teacher</span><br>    <span class="hljs-comment">//Object &gt; Person &gt; Student</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>    System.out.println(object <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">//true</span><br>    System.out.println(object <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">//true</span><br>    System.out.println(object <span class="hljs-keyword">instanceof</span> Object); <span class="hljs-comment">//true</span><br>    System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher); <span class="hljs-comment">//False</span><br>    System.out.println(object <span class="hljs-keyword">instanceof</span> String); <span class="hljs-comment">//False</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果将<code>object</code>变成<code>Person</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">System.out.<span class="hljs-keyword">println</span>(Person <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Person <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Person <span class="hljs-keyword">instanceof</span> Object); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Person <span class="hljs-keyword">instanceof</span> Teacher); <span class="hljs-comment">//False</span><br>   System.out.<span class="hljs-keyword">println</span>(Person <span class="hljs-keyword">instanceof</span> String); <span class="hljs-comment">//编译报错（Person和String是同级的）</span><br></code></pre></td></tr></table></figure><p>换成<code>Student</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">System.out.<span class="hljs-keyword">println</span>(Student <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Student <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Student <span class="hljs-keyword">instanceof</span> Object); <span class="hljs-comment">//true</span><br>   System.out.<span class="hljs-keyword">println</span>(Student <span class="hljs-keyword">instanceof</span> Teacher); <span class="hljs-comment">//编译报错</span><br>   System.out.<span class="hljs-keyword">println</span>(Student <span class="hljs-keyword">instanceof</span> String); <span class="hljs-comment">//编译报错（Person和String是同级的）</span><br></code></pre></td></tr></table></figure></li><li><p>强制转化</p><p>在Person类里面有run（父）<br>在Student类里面有go（子）<br>想要  对象  调用go就要   Perso类型强制转化为Student类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类型之间的转化： 父  子</span><br>        <span class="hljs-comment">//高                低</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">//student将这个对象转换为Student类型，我们就可以使用Student类型的方法了！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) obj;<br>        student.go();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(Student) obj.go();<span class="hljs-comment">//或者直接这样</span><br></code></pre></td></tr></table></figure></li></ul><p>总结：</p><ol><li>父类引用指向子类的对象</li><li>把子类转换为父类，向上转型（子类的方法可能会部分丢失）</li><li>把父类转换为子类，向下转型:强制转换</li><li>方便方法调用，减少重复代码</li></ol><ul><li>向上转型，这让代码更灵活（比如用父类作为方法参数，兼容所有子类）</li><li>向下转型为了突破父类引用的限制，访问子类特有的功能</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> string name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>静态方法和非静态方法</p><ul><li><p>静态</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Student<span class="hljs-selector-class">.go</span>();<br>或者<br><span class="hljs-built_in">go</span>();<br></code></pre></td></tr></table></figure></li><li><p>非静态</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student <span class="hljs-attribute">s1</span>=new Student;<br>s1.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>看静态属性和非静态属性</p><ul><li><p>静态属性</p><p>可以作为类变量调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Student.age);<br><span class="hljs-comment">//name就不行</span><br></code></pre></td></tr></table></figure></li><li><p>属性</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Student s1=<span class="hljs-built_in">new</span> Student;<br>//这俩都能通过对象访问<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s1.age);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s1.name);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>匿名代码块（啥也没，就俩大括号）</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>静态代码块·（<strong>只执行一次</strong>）</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">static</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>最早输出的是：   静态代码块—匿名代码块—构造方法</p><p>第二次输出：匿名代码块—构造方法</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li><p>abstract</p><p>空着，先不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//abstract 抽象类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-comment">//约束~有人帮我们实现~</span><br>    <span class="hljs-comment">//abstract ，抽象方法，只有方法名字，没有方法的实现！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承抽象类 需要重写抽象方法</p></li><li><p>总结：</p><ol><li>不能new这个抽象类，只能靠子类去实现它：约束!（强制重写）</li><li>抽象类中可以写普通的方法</li><li>抽象方法必须在抽象类中</li></ol></li></ul><p>用于处理 <strong>一组具有共性但实现不同的事物</strong>，减少代码量（比如动物的叫声）</p><p>（针对用途）对比重写和抽象：</p><ul><li>重写：是实现抽象约束的核心手段，但是普通方法是“可选性”重写</li><li>抽象：抽象类的抽象方法强制要求必须重写</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125615305.png" alt="image-20251025193727309"></p><p>​类        抽象类        接口</p><ul><li><p>接口:只有规范!自己无法写方法~专业的约束!约束和实现分离:面向接口编程</p><p><strong>接口的本质是契约</strong>（就像我们人间的法律一样。制定好后大家都遵守）</p></li><li><p>多用接口，少用重写：</p><p>原因：接口可以多继承，重写单继承（excends）</p></li><li><p>interface定义关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//interface 定义的关键字， 接口都需要有实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">//接口中的所有定义其实都是抽象的 public abstract（因为默认，所以隐藏了）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">TimeService</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口要有实现类  implements（关键词）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.demo09;<br><br><span class="hljs-comment">// 抽象类： extends~</span><br><span class="hljs-comment">// 类 可以实现接口 implements 接口</span><br><span class="hljs-comment">// 实现了接口的类，就需要重写接口中的方法~</span><br><br><span class="hljs-comment">// 多继承~利用接口实现多继承~</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>, TimeService &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timer</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>作用：</p><ol><li>约束</li><li>定义一些方法，让不同的人实现    10——-1</li><li>public abstract    （）</li><li>public static final    （常量）</li><li>接口不能被实例化<del>，接口中没有构造方法</del></li><li>implements可以实现多个接日</li><li>必须要重写接口中的方法~</li></ol><h2 id="内部类（选）"><a href="#内部类（选）" class="headerlink" title="内部类（选）"></a>内部类（选）</h2><ul><li><p>成员内部类</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125618721.png" alt="image-20251025201724763"></p><p>而且，可以通过<strong>内部类</strong>来获得<strong>外部类的私有属性</strong>（private）</p><p>但是，如果在内部类上加static，就访问不了私有属性</p><p>因为：先实例化static内部类，才有外部类实例化，static内部类直接运行调用不到私有属性</p></li><li><p>两个类可以在一个文件里面（不是互相包含的）</p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125623584.png" alt="image-20251025202950608" style="zoom:33%;" /><p>一个文件只能有一个public class</p></li><li><p>局部内部类</p><p>方法里 写类</p><p><img src="https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251027125625249.png" alt="image-20251025203107344"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/22/hello-world/"/>
    <url>/2024/12/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
